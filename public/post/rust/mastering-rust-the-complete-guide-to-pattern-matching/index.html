<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=preload href=https://atharvapandey.com/css/frameworks.min.css as=style><link rel=stylesheet href=https://atharvapandey.com/css/frameworks.min.css media=print onload='this.media="all"'><noscript><link rel=stylesheet href=https://atharvapandey.com/css/frameworks.min.css></noscript><link rel=stylesheet href=https://atharvapandey.com/css/github.min.css><link rel=stylesheet href=https://atharvapandey.com/css/github-style.css><link rel=stylesheet href=https://atharvapandey.com/css/light.css><link rel=stylesheet href=https://atharvapandey.com/css/dark.css><link rel=stylesheet href=https://atharvapandey.com/css/syntax.css><link rel=stylesheet href=https://unpkg.com/applause-button/dist/applause-button.css><script defer src=https://unpkg.com/applause-button/dist/applause-button.js></script><title>Mastering Rust: The Complete Guide to Pattern Matching - Atharva Pandey</title>
<link rel=icon type=image/x-icon href=/images/favicon.ico><meta name=theme-color content="#1e2327"><script defer src=https://atharvapandey.com/js/theme-mode.js></script><meta name=description content="Dive into Atharva Pandey's tech blog for expert insights on software development, architecture, and cutting-edge technologies like Rust, Go, JavaScript, Blockchain, and AI. Decaf is BS, and so are half-baked tech articles."><meta name=keywords content="Atharva Pandey,tech blog,software development,programming,Rust,Go,JavaScript,React,TypeScript,software architecture,blockchain,AI,distributed systems,computer science"><link rel=canonical href=https://atharvapandey.com/post/rust/mastering-rust-the-complete-guide-to-pattern-matching/><meta name=robots content="index, follow"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="https://atharvapandey.com/"><meta name=twitter:creator content="Atharva Pandey"><meta name=twitter:title content="Mastering Rust: The Complete Guide to Pattern Matching - Atharva Pandey"><meta name=twitter:description content="Looking to take your Rust skills to the next level? Master the art of pattern matching, one of Rust&amp;rsquo;s most versatile features! This beginner-friendly guide dives into the key concepts with clear examples, helping you:
Understand the basics of advanced pattern matching in Rust. Apply these techniques to write cleaner, more efficient code. Avoid common pitfalls and best practices to follow. 1. Basics of Pattern Matching 1.1 What is Pattern Matching?"><meta name=twitter:image content="https://atharvapandey.com/"><meta property="og:type" content="article"><meta property="og:title" content="Mastering Rust: The Complete Guide to Pattern Matching - Atharva Pandey"><meta property="og:description" content="Looking to take your Rust skills to the next level? Master the art of pattern matching, one of Rust&amp;rsquo;s most versatile features! This beginner-friendly guide dives into the key concepts with clear examples, helping you:
Understand the basics of advanced pattern matching in Rust. Apply these techniques to write cleaner, more efficient code. Avoid common pitfalls and best practices to follow. 1. Basics of Pattern Matching 1.1 What is Pattern Matching?"><meta property="og:url" content="https://atharvapandey.com/post/rust/mastering-rust-the-complete-guide-to-pattern-matching/"><meta property="og:site_name" content="Atharva Pandey"><meta property="og:image" content="https://atharvapandey.com/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2024-02-29 18:30:00 +0000 UTC"><link rel=dns-prefetch href=https://www.googletagmanager.com><link href=https://www.googletagmanager.com rel=preconnect crossorigin></head><body><div style=position:relative><header class="flex-wrap px-3 Header js-details-container Details px-md-4 px-lg-5 flex-md-nowrap open Details--on"><div class="Header-item mobile-none" style=margin-top:-4px;margin-bottom:-4px><a class=Header-link href=https://atharvapandey.com/ aria-label=Homepage><img class=octicon height=32 width=32 alt=Logo src=/images/nerdy-crab-light.webp></a></div><div class="Header-item d-md-none"><button class="Header-link btn-link js-details-target" type=button aria-expanded=false aria-controls=header-search>
<img height=24 class="octicon octicon-three-bars" width=24 alt=Menu src=/images/nerdy-crab-light.webp></button></div><div style=display:none id=header-search class="mt-3 mr-0 Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-md-3 mt-md-0 Details-content--hidden-not-important d-md-flex"><div class="flex-auto mb-3 mr-0 Header-search header-search js-site-search position-relative flex-self-stretch flex-md-self-auto mb-md-0 mr-md-3 scoped-search site-scoped-search js-jump-to"><div class=position-relative><form target=_blank action=https://www.google.com/search accept-charset=UTF-8 method=get autocomplete=off role=search><label class="p-0 Header-search-label form-control input-sm header-search-wrapper js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center"><input type=search class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable" name=q placeholder=Search autocomplete=off aria-label=Search>
<input type=hidden name=as_sitesearch value=https://atharvapandey.com/></label></form></div></div></div><div class="Header-item Header-item--full flex-justify-center d-md-none position-relative"><a class=Header-link href=https://atharvapandey.com/ aria-label=Homepage><img class="octicon octicon-mark-github v-align-middle" height=32 width=32 alt=Logo src=/images/nerdy-crab-light.webp></a></div><div class=Header-item style=margin-right:0><button class="border-none Header-link no-select" onclick=switchTheme() aria-label="Switch Theme"><svg style="fill:var(--color-profile-color-modes-toggle-moon)" class="no-select" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.52208 7.71754c3.05612.0 5.53362-2.47748 5.53362-5.5336C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961 9.95801 1.07727 10.3495.771159 10.6474.99992c1.4679 1.12724 2.4141 2.90007 2.4141 4.89391.0 3.40575-2.7609 6.16667-6.16665 6.16667-2.94151.0-5.40199-2.0595-6.018122-4.81523C.794841 6.87902 1.23668 6.65289 1.55321 6.85451 2.41106 7.40095 3.4296 7.71754 4.52208 7.71754z"/></svg></button></div></header></div><div><main><div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4"><div class=px-0><div class="mb-3 d-flex px-3 px-md-3 px-lg-5"><div class="flex-auto min-width-0 width-fit mr-3"><div class=d-flex><div class="d-none d-md-block"><a class="avatar mr-2 flex-shrink-0" href=https://atharvapandey.com/><img class=avatar-user src=/images/avatar.webp width=32 height=32></a></div><div class="d-flex flex-column"><h1 class="break-word f3 text-normal mb-md-0 mb-1"><span class=author><a href=https://atharvapandey.com/>Atharva Pandey</a></span><span class=path-divider>/</span><strong class="css-truncate-target mr-1" style=max-width:410px><a href=https://atharvapandey.com/post/rust/mastering-rust-the-complete-guide-to-pattern-matching/>Mastering Rust: The Complete Guide to Pattern Matching</a></strong></h1><div class="note m-0">Created <relative-time datetime="Thu, 29 Feb 2024 18:30:00 +0000" class=no-wrap>Thu, 29 Feb 2024 18:30:00 +0000</relative-time>
<span class=file-info-divider></span>
Modified <relative-time datetime="Thu, 29 Feb 2024 18:30:00 +0000" class=no-wrap>Thu, 29 Feb 2024 18:30:00 +0000</relative-time></div></div></div></div></div></div></div><div class="container-lg px-3 new-discussion-timeline"><div class="repository-content gist-content"><div><div class="js-gist-file-update-container js-task-list-container file-box"><div id=file-pytest class="file my-2"><div id=post-header class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style=z-index:2><div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto"><div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0"><summary id=toc-toggle onclick=clickToc() class="btn btn-octicon m-0 mr-2 p-2"><svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered"><path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zm0 5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zm0 5a.75.75.0 000 1.5h8.5a.75.75.0 000-1.5h-8.5zM3 8A1 1 0 111 8a1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"/></svg></summary><details-menu class=SelectMenu id=toc-details style="display: none;"><div class="SelectMenu-modal rounded-3 mt-1" style=max-height:340px><div class="SelectMenu-list SelectMenu-list--borderless p-2" style=overscroll-behavior:contain id=toc-list></div></div></details-menu>2467 Words</div><div class="file-actions flex-order-2 pt-0"><a class="muted-link mr-3" href=/tags/rust><svg class="octicon octicon-tag" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M2.5 7.775V2.75a.25.25.0 01.25-.25h5.025a.25.25.0 01.177.073l6.25 6.25a.25.25.0 010 .354l-5.025 5.025a.25.25.0 01-.354.0l-6.25-6.25A.25.25.0 012.5 7.775zm-1.5.0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464.0.91.184 1.238.513l6.25 6.25a1.75 1.75.0 010 2.474l-5.026 5.026a1.75 1.75.0 01-2.474.0l-6.25-6.25A1.75 1.75.0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z"/></svg>
rust
</a><a class="muted-link mr-3" href=/tags/rust-tutorial><svg class="octicon octicon-tag" viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M2.5 7.775V2.75a.25.25.0 01.25-.25h5.025a.25.25.0 01.177.073l6.25 6.25a.25.25.0 010 .354l-5.025 5.025a.25.25.0 01-.354.0l-6.25-6.25A.25.25.0 012.5 7.775zm-1.5.0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464.0.91.184 1.238.513l6.25 6.25a1.75 1.75.0 010 2.474l-5.026 5.026a1.75 1.75.0 01-2.474.0l-6.25-6.25A1.75 1.75.0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z"/></svg>
rust tutorial</a></div></div></div><div class="Box-body px-5 pb-5" style=z-index:1><article class="markdown-body entry-content container-lg"><p><img src=/images/Default_create_rust_programming_ferris_the_crab_logo_4.webp alt><br>Looking to take your Rust skills to the next level? Master the art of pattern matching, one of Rust&rsquo;s most versatile features! This beginner-friendly guide dives into the key concepts with clear examples, helping you:</p><ul><li>Understand the basics of advanced pattern matching in Rust.</li><li>Apply these techniques to write cleaner, more efficient code.</li><li>Avoid common pitfalls and best practices to follow.</li></ul><h2 id=1-basics-of-pattern-matching>1. Basics of Pattern Matching</h2><h4 id=11-what-is-pattern-matching>1.1 What is Pattern Matching?</h4><p>Imagine a toolbox filled with different tools for different tasks. Pattern matching works similarly, allowing you to compare your data against various &ldquo;patterns&rdquo; and execute the exact code you need based on the match. This brings more flexibility and security compared to traditional &ldquo;if-else&rdquo; statements in other languages.<br><br><strong>Getting Started with match:</strong></p><p>Think of match as our trusty toolbox master. It takes any data and compares it to different &ldquo;patterns&rdquo; (like tools). If a match is found, the corresponding code within that pattern gets executed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> number <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> number {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;One!&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Two!&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>3</span> <span style=color:#f92672>|</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Three or Four!&#34;</span>),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Something else!&#34;</span>), <span style=color:#75715e>// Default case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>In this example, number is compared to different patterns: 1, 2, 3 or 4, and anything else. Since number is 4, the code under the 3 or 4 pattern executes, printing &ldquo;Three or Four!&rdquo;.<br><br>Matching Beyond Numbers:</p><p>Pattern matching isn&rsquo;t limited to numbers. You can also match against other data types, like pairs of values (tuples):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> pair <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> pair {
</span></span><span style=display:flex><span>  (<span style=color:#ae81ff>0</span>, y) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Y is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, y),
</span></span><span style=display:flex><span>  (x, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;X is </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x),
</span></span><span style=display:flex><span>  _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;No match&#34;</span>), <span style=color:#75715e>// Default case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Here, pair is compared against different tuple patterns. If the first element is 0, it prints the second element. Similarly, if the second element is 0, it prints the first element. Otherwise, it prints &ldquo;No match&rdquo;.</p><h4 id=12-usingif-letfor-concise-control-flow>1.2 Using if let for Concise Control Flow</h4><p>if let is a handy shortcut for pattern matching that lets you handle specific cases more concisely. It&rsquo;s ideal when you only care about one pattern and want to ignore the rest.</p><p>Comparing if let and match:</p><p>Imagine you&rsquo;re checking if a specific book exists in your library. match allows you to compare the book title against all your books, while if let lets you directly check for that specific title:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// Using match:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> book_title <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;The Hitchhiker&#39;s Guide to the Galaxy&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> book_title {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;The Hitchhiker&#39;s Guide to the Galaxy&#34;</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Found it!&#34;</span>),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Not in the library.&#34;</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Using if let (more concise):
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> <span style=color:#e6db74>&#34;The Hitchhiker&#39;s Guide to the Galaxy&#34;</span> <span style=color:#f92672>=</span> book_title {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Found it!&#34;</span>);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Not in the library.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Both approaches achieve the same outcome, but if let is more concise when you only care about one match.</p><p>Practical Examples</p><p>Here are some practical examples of using if let for concise control flow:</p><p>1. Checking for Option Values:</p><p>Imagine you have an Option value that might contain a number or might be None. You can use if let to check for its existence and handle its value conveniently:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> some_option <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>42</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(value) <span style=color:#f92672>=</span> some_option {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Found a value: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, value);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The option is None.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><br>This code checks if some_option is Some and prints the contained value (&ldquo;42&rdquo;) if it is. This approach is more concise and readable compared to using a match expression for a single-case check.</p><p>2. Destructuring Tuples with if let:</p><p>You can also use if let to destructure tuples and access their elements directly:\</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> coordinates <span style=color:#f92672>=</span> (<span style=color:#ae81ff>3</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> (x, y) <span style=color:#f92672>=</span> coordinates {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;X: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, Y: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=13-deconstructing-tuples-and-structs>1.3 Deconstructing Tuples and Structs</h4><p>Pattern matching excels at breaking down complex data structures like tuples and structs into their individual components. This allows you to extract specific values and work with them directly.</p><p>Extracting Values from Tuples:</p><p>Imagine you have a tuple containing various data types, like a number, a string, a float, and a boolean. You can use match to deconstruct it and access specific elements:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> tuple <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;hello&#34;</span>, <span style=color:#ae81ff>4.5</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> tuple {
</span></span><span style=display:flex><span>    (x, _, y, <span style=color:#66d9ef>true</span>) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;First element: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, Third element: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;No match&#34;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code deconstructs the tuple, assigning the first element to x, skipping the second element (_), assigning the third element to y, and only matching if the last element is true. Then, it prints the values of x and y.</p><p>Nested Deconstruction for Structs:</p><p>Pattern matching can also be used with structs to extract specific fields and perform conditional checks based on their values. Consider a Point struct with x and y coordinates:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Point</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}<span style=color:#66d9ef>let</span> point <span style=color:#f92672>=</span> Point { x: <span style=color:#ae81ff>0</span>, y: <span style=color:#ae81ff>7</span> };<span style=color:#66d9ef>match</span> point {
</span></span><span style=display:flex><span>    Point { x, y: <span style=color:#ae81ff>0</span> } <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;On the X axis at </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x),
</span></span><span style=display:flex><span>    Point { x: <span style=color:#ae81ff>0</span>, y } <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;On the Y axis at </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, y),
</span></span><span style=display:flex><span>    Point { x, y } <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;On neither axis: (</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>)&#34;</span>, x, y),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=2-advanced-techniques>2. Advanced Techniques</h2><h4 id=21-matching-enums-and-nested-structs>2.1 Matching Enums and Nested Structs</h4><p>Pattern matching shines when dealing with complex data types like enums and nested structs. It allows you to:</p><ul><li>Match specific variants of enums: Enums often represent different states or options in your program. Pattern matching lets you handle each variant individually.</li><li>Deconstruct nested structs: Extract specific fields from nested structs within an enum or directly.</li></ul><p>Example: Matching Web Events:</p><p>Imagine an enum representing web events:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>WebEvent</span> {
</span></span><span style=display:flex><span>    PageLoad,
</span></span><span style=display:flex><span>    PageUnload,
</span></span><span style=display:flex><span>    KeyPress(<span style=color:#66d9ef>char</span>),
</span></span><span style=display:flex><span>    Paste(String),
</span></span><span style=display:flex><span>    Click { x: <span style=color:#66d9ef>i32</span>, y: <span style=color:#66d9ef>i32</span> },
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><br>We can use a match statement to handle each event type:\</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> event <span style=color:#f92672>=</span> WebEvent::Click { x: <span style=color:#ae81ff>100</span>, y: <span style=color:#ae81ff>200</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> event {
</span></span><span style=display:flex><span>    WebEvent::PageLoad <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;page loaded&#34;</span>),
</span></span><span style=display:flex><span>    WebEvent::PageUnload <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;page unloaded&#34;</span>),
</span></span><span style=display:flex><span>    WebEvent::KeyPress(c) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;pressed &#39;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;&#34;</span>, c),
</span></span><span style=display:flex><span>    WebEvent::Paste(s) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;pasted </span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>{}</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>&#34;</span>, s),
</span></span><span style=display:flex><span>    WebEvent::Click { x, y } <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;clicked at x=</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y=</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x, y),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This example shows how to match each variant of the WebEvent enum, including those with nested data like the Click variant.</p><h4 id=22-patterns-and-guards>2.2 Patterns and Guards</h4><p>Guards are conditions attached to patterns for more refined control. They allow you to add additional checks beyond the simple pattern match.</p><p>Example: Matching Numbers with Conditions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> num <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> num {
</span></span><span style=display:flex><span>    Some(x) <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Less than five: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x), <span style=color:#75715e>// Guard: x is less than 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Some(x) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;x: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, x),
</span></span><span style=display:flex><span>    None <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;No match&#34;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, the if clause after Some(x) acts as a guard, ensuring x is less than 5 before proceeding.</p><p>Combining Guards with Complex Patterns:</p><p>Guards can be used with various patterns and even embedded in if let expressions.</p><h4 id=23--bindings>2.3 @ Bindings</h4><p>The @ operator in Rust&rsquo;s pattern matching offers a powerful way to bind values extracted from patterns and use them later in your code. Think of it as attaching a temporary label to a matched value, making it accessible within the current match arm. The @ operator sits directly before a variable name within a pattern. It essentially says, &ldquo;If this part of the pattern matches, assign the extracted value to this variable.&rdquo;</p><p>Example: Matching Within a Range:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> msg <span style=color:#f92672>=</span> Message::Move { x: <span style=color:#ae81ff>20</span>, y: <span style=color:#ae81ff>35</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> msg {
</span></span><span style=display:flex><span>    Message::Move { x: <span style=color:#a6e22e>a</span> <span style=color:#f92672>@</span> <span style=color:#ae81ff>10</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>20</span>, y: <span style=color:#a6e22e>b</span> <span style=color:#f92672>@</span> <span style=color:#ae81ff>30</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>40</span> } <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// Bind x and y to a and b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        println!(<span style=color:#e6db74>&#34;In range: x=</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, y=</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, a, b);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Out of range&#34;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this example:</p><ul><li>We&rsquo;re matching against the Message::Move variant.</li><li>Within the pattern, x: a @ 10..=20 uses @ to bind the extracted x value to the variable a. Additionally, it checks if x is within the range 10 to 20.</li><li>Similarly, y: b @ 30..=40 binds the extracted y value to b and checks if it&rsquo;s between 30 and 40.</li></ul><ol><li>Using the Bound Values:</li></ol><p>After the => arrow, you can access these bound variables (a and b) just like any other variables within the current match arm. Here, we use them to print both coordinates if they fall within the specified ranges. Note: The @ operator only applies to the current match arm where it&rsquo;s used. Bound variables are not accessible outside the arm.</p><p>Benefits of @ Bindings:</p><ul><li>Cleaner Code: Avoids repetition by assigning extracted values to named variables, making the code more readable and maintainable.</li><li>Using Values with Guards: Can be combined with guards to perform additional checks on the bound values before proceeding.</li></ul><h4 id=24-matching-on-references-and-pointers>2.4 Matching on References and Pointers</h4><p>Rust distinguishes between matching on values and dereferencing pointers. This is crucial when working with references and smart pointers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> reference <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span><span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> reference {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>val <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Got a value via destructuring: </span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, val), <span style=color:#75715e>// Destructure reference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Here, we need to destructure the reference &amp;10 to access its underlying value (val) for comparison.</p><p>Matching on Smart Pointers:</p><p>Smart pointers like Box can be dereferenced in patterns to match their contained values:\</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> boxed_num <span style=color:#f92672>=</span> Box::new(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> boxed_num {
</span></span><span style=display:flex><span>    Box::new(num) <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Box contains: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, num), <span style=color:#75715e>// Dereference Box
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This code matches a Box containing the number 5 and extracts the number into num using dereferencing.</p><p>2.5 Advanced Slice Patterns</p><p>Rust&rsquo;s pattern matching extends to slices, allowing powerful and expressive matching based on their contents.</p><p>Matching Slices with Variable Lengths:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> numbers <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> numbers {
</span></span><span style=display:flex><span>    [first, <span style=color:#f92672>..</span>, last] <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;First: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>, last: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, first, last),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This matches any slice with at least two elements, binding the first and last elements to first and last.</p><p>Utilizing .. in Patterns to Ignore Parts of a Slice</p><p>The .. syntax can also be used to ignore any number of elements in a slice:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>match</span> numbers {
</span></span><span style=display:flex><span>    [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#f92672>..</span>] <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Starts with 1, 2&#34;</span>),
</span></span><span style=display:flex><span>    [<span style=color:#f92672>..</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>] <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Ends with 4, 5&#34;</span>),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Does not match&#34;</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code snippet includes two patterns: one for slices starting with [1, 2] and another for slices ending with [4, 5].</p><h4 id=26-using-pattern-matching-in-function-parameters>2.6 Using Pattern Matching in Function Parameters</h4><p>Rust allows you to use patterns directly in function parameters, enabling concise and expressive function definitions. This means the function can match specific data structures and extract their values within the parameter list itself.</p><p>Defining Functions That Accept Patterns Directly as Arguments</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>greet</span>((name, age): (<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>str</span>, <span style=color:#66d9ef>u32</span>)) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Hello, </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>. You are </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> years old.&#34;</span>, name, age);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>greet((<span style=color:#e6db74>&#34;Alice&#34;</span>, <span style=color:#ae81ff>30</span>));
</span></span></code></pre></div><p>In this example, the greet function takes a tuple as an argument and uses pattern matching to deconstruct it into individual variables name and age directly within the parameter list. This eliminates the need for explicit destructuring within the function body.</p><p>Practical Applications:</p><p>Using patterns in function parameters can simplify code, especially when dealing with commonly used data structures like tuples or structs. Here are some benefits:</p><ul><li>Improved Readability: The code becomes more concise and easier to understand, as the purpose of each parameter is evident from the pattern itself.</li><li>Reduced Boilerplate: Explicit destructuring within the function body is no longer required, reducing code duplication and improving maintainability.</li></ul><p>Limitations:</p><p>While pattern matching in function parameters offers several advantages, it&rsquo;s important to consider potential drawbacks:</p><ul><li>Reduced Flexibility: Complex patterns within parameters can make the function less flexible and harder to understand for others reading your code. ( Hello JS :P )</li><li>Over-complication: Overusing complex patterns can lead to overly intricate function signatures, potentially hindering readability and maintainability.</li></ul><h2 id=3-best-practices-and-anti-patterns>3. Best Practices and Anti-Patterns</h2><h4 id=31-leveraging-exhaustiveness-checking>3.1 Leveraging Exhaustiveness Checking</h4><p>One of Rust&rsquo;s strengths is the enforced exhaustiveness of match expressions. This means you must handle all possible cases for the data type being matched, preventing bugs from unhandled scenarios.</p><p>Benefits:</p><ul><li>Future-proof code: Ensures your code adapts to future additions to enums or other matched types.</li><li>Bug prevention: Avoids errors that might occur when new cases are introduced without updating the match expression.</li></ul><p>Using _ and .. Patterns:</p><ul><li>_ as catch-all: Use the underscore pattern (_) to match any value you&rsquo;re not explicitly interested in, ensuring all possible cases are covered.</li><li>.. for ignoring parts: In complex data structures, use .. to ignore parts of the data you don&rsquo;t need.</li></ul><p>Examples:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>match</span> some_value {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;One!&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>2</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Two!&#34;</span>),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Something else!&#34;</span>), <span style=color:#75715e>// Catch-all for any other value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Person</span> { name: String, age: <span style=color:#66d9ef>u32</span>, <span style=color:#75715e>/* Other fields */</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> person <span style=color:#f92672>=</span> Person { name: String::from(<span style=color:#e6db74>&#34;Alice&#34;</span>), age: <span style=color:#ae81ff>30</span> <span style=color:#75715e>/* Other fields */</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>match</span> person {
</span></span><span style=display:flex><span>    Person { name, <span style=color:#f92672>..</span> } <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Found person named </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, name), <span style=color:#75715e>// Ignore other fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=32-clarity-and-maintainability-in-patterns>3.2 Clarity and Maintainability in Patterns</h4><p>While powerful, pattern matching needs clear and maintainable patterns. Complex patterns can be difficult to read and understand.</p><p>Tips for Clear Patterns:</p><ul><li>Simplicity: Keep patterns straightforward and easy to grasp.</li><li>Descriptive names: Use meaningful variable names within the patterns.</li><li>Avoid nesting: Break down deeply nested patterns into smaller, simpler ones for improved readability.</li></ul><p>Refactoring Complex Matches:</p><p>If a match expression becomes too intricate, consider:</p><ul><li>Helper functions: Break down logic into separate functions for better organization.</li><li>Multiple smaller matches: Divide complex logic into several simpler match expressions.</li></ul><h4 id=33-avoiding-overly-complicated-patterns>3.3 Avoiding Overly Complicated Patterns</h4><p>Sometimes, other control flow structures might be more efficient than overly complex patterns.</p><p>Signs of a Complex Pattern:</p><ul><li>Multiple guards within a single pattern</li><li>Deep nesting of patterns</li><li>Intricate combinations of patterns and @ bindings</li></ul><p>Exploring Alternatives:</p><p>In such cases, consider using:</p><ul><li>if-else chains for simpler conditional logic.</li><li>for loops for iterating through data structures.</li><li>Early returns to exit functions early based on conditions.</li></ul><h4 id=34-performance-considerations>3.4 Performance Considerations</h4><p>Pattern matching is generally efficient, but certain aspects can impact performance:</p><ul><li>Deep nesting and guards: Deeply nested patterns and extensive use of guards can introduce overhead.</li><li>Matching large data structures: Excessive data copying can occur when matching against large structs or arrays.</li></ul><p>When to Be Mindful of Performance:</p><ul><li>Performance-critical code: Avoid deep matching against large data structures in these sections.</li><li>Use references: Employ references to prevent unnecessary data copying.</li></ul><p>3.5 Common Anti-Patterns</p><p>Be aware of common misuse cases to avoid them:</p><ul><li>Overusing match for simple cases: Use if let for single-case checks instead of complex match expressions.</li><li>Overly complex patterns: Avoid patterns with multiple guards and @ bindings, as they can obfuscate the code&rsquo;s intent.</li></ul><p>Example and Refactored Solution:</p><p>Anti-pattern:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>match</span> some_option {
</span></span><span style=display:flex><span>    Some(x) <span style=color:#66d9ef>if</span> x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Greater than 10&#34;</span>),
</span></span><span style=display:flex><span>    Some(_) <span style=color:#f92672>=&gt;</span> (),
</span></span><span style=display:flex><span>    None <span style=color:#f92672>=&gt;</span> (),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Refactored solution (using if let):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(x) <span style=color:#f92672>=</span> some_option <span style=color:#f92672>&amp;&amp;</span> x <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Greater than 10&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The refactored solution uses if let with a guard for a clearer and more concise expression of the intent.</p><h2 id=conclusion>Conclusion</h2><p>We&rsquo;ve covered a lot about Rust&rsquo;s pattern matching, from the basics to some pretty advanced stuff. I hope it helps you write cleaner and more efficient Rust code. If you liked this guide, a clap or a follow would mean a lot! It&rsquo;s a great way to show support and stay connected for more Rust tips. Happy coding!</p></article></div></div></div></div></div></div></main></div><script type=application/javascript src=https://atharvapandey.com/js/toc.js></script><link rel=stylesheet href=https://atharvapandey.com/css/toc.css><div class="px-3 container-lg new-discussion-timeline"><script defer src=https://giscus.app/client.js data-repo=gopherine/hugo-blog data-repo-id=R_kgDOLTrS1w data-category=Announcements data-category-id data-mapping=title data-strict=0 data-reactions-enabled data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><applause-button style="width: 58px; height: 58px; position: fixed; bottom: 20px; left: 20px;"><div class="footer container-xl width-full p-responsive"><div class="flex-row-reverse flex-wrap pt-6 pb-2 mt-6 position-relative d-flex flex-lg-row flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center f6 text-gray border-top border-gray-light"><a aria-label=Homepage title=GitHub class="footer-octicon d-none d-lg-block mr-lg-4" href=https://atharvapandey.com/><svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" width="24"><path fill-rule="evenodd" d="M8 0C3.58.0.0 3.58.0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38.0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95.0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12.0.0.67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15.0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48.0 1.07-.01 1.93-.01 2.2.0.21.15.46.55.38A8.013 8.013.0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><ul class="flex-wrap mb-2 list-style-none d-flex col-12 flex-justify-center flex-lg-justify-between mb-lg-0"><li class="mr-3 mr-lg-0">Copyright © 2024 Atharva Pandey</li></ul></div><div class="pb-6 d-flex flex-justify-center"><span class="f6 text-gray-light"></span></div></div></body><script defer type=application/javascript src=https://atharvapandey.com/js/github-style.js></script></html>